#!/usr/bin/env python

# Copyright (c) 2012 OpenStack Foundation
# Copyright (c) 2010 Citrix Systems, Inc.
# Copyright 2010 United States Government as represented by the
# Administrator of the National Aeronautics and Space Administration.
# All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

"""Handle the uploading and downloading of images via Glance."""
import cPickle as pickle
import httplib
import md5
import urllib2

import utils

import pluginlib_nova

# jbuhacoff start
import subprocess
# jbuhacoff end


pluginlib_nova.configure_logging('glance')
logging = pluginlib_nova.logging
PluginError = pluginlib_nova.PluginError
with_vdi_in_dom0 = pluginlib_nova.with_vdi_in_dom0

class RetryableError(Exception):
    pass


# jbuhacoff added extra_params after staging_path
#def _download_tarball_and_verify(request, staging_path):
def _download_tarball_and_verify(request, staging_path, extra_params):
    # jbuhacoff added get dek from kms if extra_params indicates image is encrypted
    #if extra_params is None: extra_params = {}
    #logging.info("mhagent hook: mh_dek_url=%s" % extra_params['mh_dek_url'])
    logging.info("mhagent hook: mh_encrypted=%s" % extra_params['mh_encrypted'])
    if extra_params['mh_encrypted'] == 'true':
        subprocess.call(['/usr/local/bin/mhagent','log','Detect VM is encrypted'])
#        subprocess.call(['/usr/local/bin/mhagent','request-dek',extra_params['mh_dek_url']])
#        extra_params['mh_dek_file'] = '/tmp/mh.dek.base64'
    # jbuhacoff end
    try:
        response = urllib2.urlopen(request,timeout=1)
    except urllib2.HTTPError, error:
        raise RetryableError(error)
    except urllib2.URLError, error:
        raise RetryableError(error)
    except httplib.HTTPException, error:
        # httplib.HTTPException and derivatives (BadStatusLine in particular)
        # don't have a useful __repr__ or __str__
        raise RetryableError('%s: %s' % (error.__class__.__name__, error))

    url = request.get_full_url()
    logging.info("Reading image data from %s" % url)

    callback_data = {'bytes_read': 0}
    checksum = md5.new()

    def update_md5(chunk):
        callback_data['bytes_read'] += len(chunk)
        checksum.update(chunk)

    try:
        try:
            # jbuhacoff added extra_params
            #utils.extract_tarball(response, staging_path, callback=update_md5)
            utils.extract_tarball(response, staging_path, callback=update_md5, extra_params=extra_params)
        except Exception, error:
            raise RetryableError(error)
    finally:
        bytes_read = callback_data['bytes_read']
        logging.info("Read %d bytes from %s", bytes_read, url)

    # Use ETag if available, otherwise X-Image-Meta-Checksum
    etag = response.info().getheader('etag', None)
    if etag is None:
        etag = response.info().getheader('x-image-meta-checksum', None)

    # Verify checksum using ETag
    checksum = checksum.hexdigest()

    if etag is None:
        msg = "No ETag found for comparison to checksum %(checksum)s"
        logging.info(msg % locals())
    elif checksum != etag:
        msg = 'ETag %(etag)s does not match computed md5sum %(checksum)s'
        raise RetryableError(msg % locals())
    else:
        msg = "Verified image checksum %(checksum)s"
        logging.info(msg % locals())


# jbuhacoff added extra_params after extra_headers
#def _download_tarball(sr_path, staging_path, image_id, glance_host,
#                      glance_port, glance_use_ssl, extra_headers):
def _download_tarball(sr_path, staging_path, image_id, glance_host,
                      glance_port, glance_use_ssl, extra_headers, extra_params):
    """Download the tarball image from Glance and extract it into the staging
    area. Retry if there is any failure.
    """
    if glance_use_ssl:
        scheme = 'https'
    else:
        scheme = 'http'

    url = ("%(scheme)s://%(glance_host)s:%(glance_port)d/v1/images/"
           "%(image_id)s" % locals())
    logging.info("Downloading %s" % url)
    logging.info("Header %s" % extra_headers)
    request = urllib2.Request(url, headers=extra_headers)
    try:
        # jbuhacoff added extra_params after staging_path
        #_download_tarball_and_verify(request, staging_path)
        _download_tarball_and_verify(request, staging_path, extra_params)
    except Exception:
        logging.exception('Failed to retrieve %(url)s' % locals())
        raise


""" MH start of retrieve manifest uuid from glance disk image metadata"""
def check_and_get_manifest_uuid(session, image_id, glance_host, glance_port, glance_use_ssl, extra_headers):
    """This function retrieve metadata of image and if manifest file attribute is present then downloads manifest file"""
    logging.info("Check and get manifest uuid");
    if glance_use_ssl:
        scheme = 'https'
    else:
        scheme = 'http'

    url = ("%(scheme)s://%(glance_host)s:%(glance_port)d/v1/images/"
           "%(image_id)s" % locals())
    logging.info("Downloading %s" % url)
    logging.info("Header %s" % extra_headers)
    request = urllib2.Request(url, headers=extra_headers)
    request.get_method = lambda : 'HEAD'
    response = urllib2.urlopen(request)
    logging.info("Headers")
    manifest_uuid = response.info().getheader('X-Image-Meta-Property-Manifest_uuid', None)
    return manifest_uuid

""" MH code end of retrieve manifest uuid from glance disk image metadata"""

""" MH start of get vdi id from vhd dict """
def get_vhd_uuid(vhds_of_vm):
    logging.info(" VHDSOFVM: %s", vhds_of_vm)
    if type(vhds_of_vm) is dict:
     tmp1 = vhds_of_vm.get('root')
     vhd_uuid = tmp1.get('uuid')
    else:
     vhd_uuid = vhds_of_vm
    return vhd_uuid

""" MH code end of get vdi id from vhd dict """


""" MH start of download manifest file """
def _download_manifest_file(sr_path, vhd_uuid, manifest_id, glance_host,
                      glance_port, glance_use_ssl, extra_headers):
    if glance_use_ssl:
        scheme = 'https'
    else:
        scheme = 'http'

    url = ("%(scheme)s://%(glance_host)s:%(glance_port)d/v1/images/"
           "%(manifest_id)s" % locals())
    logging.info("Downloading %s" % url)
    logging.info("Header %s" % extra_headers)
    request = urllib2.Request(url, headers=extra_headers)
    try:
        response = urllib2.urlopen(request,timeout=1)
        manifest_filepath = sr_path +'/'+ vhd_uuid+'.manifest'
        logging.info("manifest_filepath = %s", manifest_filepath)
        output = open(manifest_filepath,'wb')
        output.write(response.read())
        output.close()
    except urllib2.HTTPError, error:
        raise RetryableError(error)
    except urllib2.URLError, error:
        raise RetryableError(error)
    except httplib.HTTPException, error:
        raise RetryableError('%s: %s' % (error.__class__.__name__, error))
    return 

""" MH code end of download manifest file """

def _upload_tarball(staging_path, image_id, glance_host, glance_port,
                    glance_use_ssl, extra_headers, properties):
    """
    Create a tarball of the image and then stream that into Glance
    using chunked-transfer-encoded HTTP.
    """
    if glance_use_ssl:
        scheme = 'https'
    else:
        scheme = 'http'

    url = '%s://%s:%s/v1/images/%s' % (scheme, glance_host, glance_port,
                                       image_id)
    logging.info("Writing image data to %s" % url)

    try:
        if glance_use_ssl:
            conn = httplib.HTTPSConnection(glance_host, glance_port)
        else:
            conn = httplib.HTTPConnection(glance_host, glance_port)
    except Exception, error:
        raise RetryableError(error)

    try:
        try:
            # NOTE(sirp): httplib under python2.4 won't accept
            # a file-like object to request
            conn.putrequest('PUT', '/v1/images/%s' % image_id)
        except Exception, error:
            raise RetryableError(error)

        # NOTE(sirp): There is some confusion around OVF. Here's a summary of
        # where we currently stand:
        #   1. OVF as a container format is misnamed. We really should be using
        #      OVA since that is the name for the container format; OVF is the
        #      standard applied to the manifest file contained within.
        #   2. We're currently uploading a vanilla tarball. In order to be
        #      OVF/OVA compliant, we'll need to embed a minimal OVF manifest
        #      as the first file.

        # NOTE(dprince): In order to preserve existing Glance properties
        # we set X-Glance-Registry-Purge-Props on this request.
        headers = {
            'content-type': 'application/octet-stream',
            'transfer-encoding': 'chunked',
            'x-image-meta-is-public': 'False',
            'x-image-meta-status': 'queued',
            'x-image-meta-disk-format': 'vhd',
            'x-image-meta-container-format': 'ovf',
            'x-glance-registry-purge-props': 'False'}

        headers.update(**extra_headers)

        for key, value in properties.iteritems():
            header_key = "x-image-meta-property-%s" % key.replace('_', '-')
            headers[header_key] = str(value)

        for header, value in headers.iteritems():
            conn.putheader(header, value)
        conn.endheaders()

        callback_data = {'bytes_written': 0}

        def send_chunked_transfer_encoded(chunk):
            chunk_len = len(chunk)
            callback_data['bytes_written'] += chunk_len
            try:
                conn.send("%x\r\n%s\r\n" % (chunk_len, chunk))
            except Exception, error:
                raise RetryableError(error)

        compression_level = properties.get('xenapi_image_compression_level')

        utils.create_tarball(
                None, staging_path, callback=send_chunked_transfer_encoded,
                compression_level=compression_level)

        try:
            conn.send("0\r\n\r\n")  # Chunked-Transfer terminator
        except Exception, error:
            raise RetryableError(error)

        bytes_written = callback_data['bytes_written']
        logging.info("Wrote %d bytes to %s" % (bytes_written, url))

        resp = conn.getresponse()
        if resp.status == httplib.OK:
            return

        logging.error("Unexpected response while writing image data to %s: "
                      "Response Status: %i, Response body: %s"
                      % (url, resp.status, resp.read()))

        if resp.status in (httplib.UNAUTHORIZED,
                           httplib.REQUEST_ENTITY_TOO_LARGE,
                           httplib.PRECONDITION_FAILED,
                           httplib.CONFLICT,
                           httplib.FORBIDDEN):
            # No point in retrying for these conditions
            raise PluginError("Got Error response [%i] while uploading "
                              "image [%s] "
                              "to glance host [%s:%s]"
                              % (resp.status, image_id,
                                 glance_host, glance_port))
        else:
            raise RetryableError("Unexpected response [%i] while uploading "
                                 "image [%s] "
                                 "to glance host [%s:%s]"
                                 % (resp.status, image_id,
                                    glance_host, glance_port))
    finally:
        conn.close()


# jbuhacoff changed method signature 
#def download_vhd(session, image_id, glance_host, glance_port, glance_use_ssl,
#                 uuid_stack, sr_path, extra_headers):
def download_vhd(session, image_id, glance_host, glance_port, glance_use_ssl,
                 uuid_stack, sr_path, auth_token, mh_encrypted, mh_checksum, extra_headers):
    """Download an image from Glance, unbundle it, and then deposit the VHDs
    into the storage repository
    """
    # jbuhacoff start
    logging.info("mhagent hook: glance download_vhd mh_encrypted=%s mh_checksum=%s" % (mh_encrypted, mh_checksum))
    subprocess.call(['/usr/local/bin/mhagent','log','Received VM launch request (glance download_vhd)', "--image-id=%s" % (image_id), "--checksum=%s" % (mh_checksum), "glance_host=%s" % (glance_host), "glance_port=%d" % (glance_port), "glance_use_ssl=%s" % (glance_use_ssl)])
    # jbuhacoff end
    staging_path = utils.make_staging_area(sr_path)
    try:
        # Download tarball into staging area and extract it
        # jbuhacoff added extra parameters after extra_headers
        #_download_tarball(
        #    sr_path, staging_path, image_id, glance_host, glance_port,
        #    glance_use_ssl, extra_headers)
        extra_params = {'mh_encrypted': mh_encrypted, 'mh_checksum': mh_checksum}
        _download_tarball(
            sr_path, staging_path, image_id, glance_host, glance_port,
            glance_use_ssl, extra_headers, extra_params)

        # Move the VHDs from the staging area into the storage repository
        #return utils.import_vhds(sr_path, staging_path, uuid_stack)
        vhds = utils.import_vhds(sr_path, staging_path, uuid_stack)
        """ MH start of function call """
        vhd = get_vhd_uuid(vhds)
        download_manifest_file(session, image_id, glance_host, glance_port, glance_use_ssl, sr_path, extra_headers, vhd)
        """ MH end of function call """

        return vhds

    finally:
        utils.cleanup_staging_area(staging_path)

""" MH start of open_glance_connection """
def open_glance_connection(image_id, host, port, glance_use_ssl, identity_headers):
    if glance_use_ssl:
        scheme = 'https'
    else:
        scheme = 'http'

    url = ("%(scheme)s://%(host)s:%(port)d/v1/images/"
           "%(image_id)s" % locals())
    logging.info("Opening connection to %s" % url ) 
    request = urllib2.Request(url, headers=identity_headers)
    response = urllib2.urlopen(request)
    
    return response

""" MH end of open_glance_connection """


""" MH start of _copy_to """
def _copy_to(target, source, offset):
    try:
        logging.info("Inside _copy_to")
        fout = open(target,'wb')
        fin  = open(source, 'rb')
        fout.seek(offset)
        logging.info("Copying data from %s to %s with offset %d" % (source, target, offset) )
        size = 0
        while True :
            data = fin.read(4096)
            if data == '' :
                break
            fout.write(data)
            size = size + len(data)
        logging.info('Total bytes copied %d' % size )
        return size
    finally:
        fout.flush()
        fin.close()
        fout.close()
""" MH end of _copy_to """


""" MH start of download_encrypted_nonvhd image from glance """
def download_encrypted_nonvhd(session, is_tgz, vdi, image_id, glance_host, glance_port, glance_use_ssl, sr_path, offset,
                              mh_encrypted, mh_checksum, identity_header,image_type):
    disk = 2
    DISK_RAW = 3
    if image_type == disk or image_type == DISK_RAW:
        extra_headers = identity_header
        vdi_uuid = session.xenapi.VDI.get_uuid(vdi)
        download_manifest_file(session, image_id, glance_host, glance_port, glance_use_ssl, sr_path, extra_headers, vdi_uuid)

    logging.info('Inside download_encrypted_nonvhd')
    logging.info('Received : %s' % (identity_header))
    if is_tgz == 'yes' :
        #Currently we are not supporting tgz formatted non vhd images. To enable tgz supoort do the following steps
        #1.Download the image from glance
        #2.Decrypt it in staging path
        #3.untar the image that in on staging path into the VDI
        return

    staging_path = utils.make_staging_area(sr_path) + '/' + image_id
    response = open_glance_connection(image_id, glance_host, glance_port, glance_use_ssl, identity_header)
    utils.decrypt(response, staging_path)
    response.close()
    return with_vdi_in_dom0(session, vdi, False,
                                lambda dev:
                               _copy_to('/dev/%s' % dev, staging_path, offset))

    logging.info('Exit from download_encrypted_nonvhd')

""" MH code end of download_encrypted_nonvhd image from glance """

""" MH start of download_manifest_file """
def download_manifest_file(session, image_id, glance_host, glance_port, glance_use_ssl, sr_path, extra_headers, vdis):
    logging.info("Inside download_manifest_file")
    vhd_uuid = get_vhd_uuid(vdis)
    logging.info("VHD UUID: %s",vhd_uuid)
    manifest_uuid = check_and_get_manifest_uuid(session, image_id, glance_host, glance_port, glance_use_ssl, extra_headers)
    if manifest_uuid is None:
        logging.info("Manifest ID not available")
    else:
        _download_manifest_file(sr_path, vhd_uuid, manifest_uuid, glance_host, glance_port, glance_use_ssl, extra_headers)

    return 

""" MH code end of download_manifest_file """

def upload_vhd(session, vdi_uuids, image_id, glance_host, glance_port,
               glance_use_ssl, sr_path, extra_headers, properties):
    """Bundle the VHDs comprising an image and then stream them into Glance.
    """
    staging_path = utils.make_staging_area(sr_path)
    try:
        utils.prepare_staging_area(sr_path, staging_path, vdi_uuids)
        _upload_tarball(staging_path, image_id, glance_host, glance_port,
                        glance_use_ssl, extra_headers, properties)
    finally:
        utils.cleanup_staging_area(staging_path)


if __name__ == '__main__':
    utils.register_plugin_calls(download_vhd, upload_vhd, download_encrypted_nonvhd, download_manifest_file)
