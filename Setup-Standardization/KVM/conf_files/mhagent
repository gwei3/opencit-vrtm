#!/bin/bash
logfile=/var/log/mhagent.log

# init
if [ ! -f $logfile ]; then touch $logfile; fi

# this command accepts two parameters:  filename, extension
# the return value is the filename without the extension, or just the filename if it
# didn't end with the specified extension
# this command is similar to the 'basename' command, which strips out the path
# and an optional extension, but does not strip out the path.
# examples:
#   basename      /path/to/filename.ext .ext   --> filename
#   path_basename /path/to/filename.ext .ext   --> /path/to/filename
#   basename      /path/to/filename.ext1 .ext2 --> filename.ext1
#   path_basename /path/to/filename.ext1 .ext2 --> /path/to/filename.ext1
path_basename() {
  local infiledir=`dirname $1`
  local infilebasename=`basename $1 $2`
  local outfile="$infiledir/$infilebasename"
  echo "$outfile"
}

md5() {
  local file="$1"
  md5sum "$file" | awk '{ print $1 }'
}


mh_log() {
  #local datestr=`date '+%Y-%m-%d %H:%M:%S'`
  # use RFC 822 format
  local datestr=`date -R`
  echo "[$datestr] $$ $@" >> $logfile
}

# arguments:  <since-timestamp>
# the <since-timestamp> required argument is a timestamp where to start extracting data from the log
# lines in the log on or after the <since-timestamp> until the end are returned
# Usage example:  mhagent getlog 1382720512
# This would print all log statements on or after "Fri, 25 Oct 2013 10:01:52 -0700"
# To obtain a timestamp from a date in that format do this: date --utc --date "Fri, 25 Oct 2013 10:01:52 -0700" +%s
mh_getlog() {
  local since="$1"
  local trigger=false
  # default timestamp format for comparison is seconds since epoch (these days an 11 digit number)
  # if the caller supplied a 14-digit number they are including milliseconds so we add zeros to our format so we can compare
  local timestamp_format="%s"
  local since_length=`echo $since | wc -c`
  if [ $since_length -eq 14 ]; then timestamp_format="%s000"; fi
  while read line
  do
    if $trigger; then
      echo $line
    else
      # Given a logfile entry like "[Fri, 25 Oct 2013 10:01:59 -0700] 7088 Decrypted VM image",
      # extract the date using   awk -F '[][]' '{ print $2 }' which  outputs   Fri, 25 Oct 2013 10:01:59 -0700
      # and pass it to the date command using xargs -i ... {} ...  to create a command line like this:
      #  date --utc --date "Fri, 25 Oct 2013 10:01:52 -0700" +%s
      # which converts the date from that format into a  timestamp like 1383322675
      local linetime=`echo $line | awk -F '[][]' '{ print $2 }' | xargs -i date --utc --date "{}" +"$timestamp_format"`
      if [ -n "$linetime" ] && [ $linetime -ge $since ]; then
        trigger=true
        echo $line
      fi
    fi
  done < $logfile
}


openssl_encrypted_file() {
  local filename="$1"
  encheader=`hd -n 8 $filename | head -n 1 | grep "Salted__"`
  if [ -n "$encheader" ]; then
    return 0
  fi
  return 1
}

mh_encrypt() {
  local infile="$1"
  local encfile="$infile.enc"
  if [ ! -f $infile ]; then
    echo "error: failed to encrypt $infile: file not found"
    return 1
  fi
  if openssl_encrypted_file $infile; then
    echo "error: failed to encrypt $infile: already encrypted";
    return 2;
  fi
  # XXX TODO need to change ciphers to aes-256-cbc and also add hmac for authentication!
  openssl enc -aes-128-ofb -in "$infile" -out "$encfile" -pass pass:password
  if openssl_encrypted_file $encfile; then
    mv $encfile $infile
    return 0
  fi
  echo "error: failed to encrypt $infile"
  return 3
}

mh_decrypt() {
  local infile="$1"
  local decfile="$infile.dec"
  if [ ! -f $infile ]; then
    echo "error: failed to decrypt $infile: file not found"
    return 1
  fi
  if ! openssl_encrypted_file $infile; then
    echo "error: failed to decrypt $infile: not encrypted";
    return 1
  fi
  if [ -n "$IMAGE_ID" ]; then
    mh_log "Found encrypted image: $IMAGE_ID"
  fi

  # XXX DEBUG for debugging only - copy the original image file to a tmp location for dev to look at it after
  cp $infile /tmp/image.enc

  # file is encrypted -- but we need the decryption key. mh_request_dek will
  # request it from the key mgmt svc and place it in the var MH_DEK
  # in order to request the dek we need to know the url from where to download
  # it, which must be provided as an argument --dek-url
  # ravindra: commenting the call mh_request_dek and putting hardcoded key 
  mh_request_dek $DEK_URL
  # XXX TODO (see note in mh_encrypt) need to change ciphers to aes-256-cbc and also add hmac for authentication!
  #openssl enc -d -aes-128-ofb -in "$infile" -out "$decfile" -pass pass:password
  export MH_DEK_DECODED=`openssl enc -base64 -d <<< $MH_DEK`
  mh_log "mh dek decoded::: $MH_DEK_DECODED";
  openssl enc -d -aes-128-ofb -in "$infile" -out "$decfile" -pass env:MH_DEK_DECODED
  if ! openssl_encrypted_file $decfile; then
    if [ -n "$IMAGE_ID" ]; then
      mh_log "Decrypted image: $IMAGE_ID"
      # XXX DEBUG for debugging only - 
      cp $decfile /tmp/image.dec
    fi
    mv $decfile $infile
    return 0
  fi
  echo "error: failed to decrypt $infile"
  return 2
  #local infiledir=`dirname $infile`
  #local infilebasename=`basename $infile .enc`
  #local outfile="$infiledir/$infilebasename"
  #mv $decfile $outfile
}

parse_args() {
  if ! options=$(getopt -n mhagent -l project-id:,instance-name:,base-image:,image-id:,target:,checksum:,dek-url: -- "$@"); then exit 1; fi
  eval set -- "$options"
  while [ $# -gt 0 ]
  do
    case $1 in
      --project-id) PROJECT_ID="$2"; shift;;
      --instance-name) INSTANCE_NAME="$2"; shift;;
      --base-image) BASE_IMAGE="$2"; shift;;
      --image-id) IMAGE_ID="$2"; shift;;
      --target) TARGET="$2"; shift;;
      --checksum) CHECKSUM="$2"; shift;;
      --dek-url) DEK_URL="$2"; shift;;
    esac
    shift
  done
}

mh_launch() {
  mh_log "mh_launch: $@"
  mh_log "Project Id: $PROJECT_ID"
  mh_log "Instance Name: $INSTANCE_NAME"
  mh_log "Base Image: $BASE_IMAGE"
  mh_log "Image Id: $IMAGE_ID"
  mh_log "Target: $TARGET"
  mh_log "Checksum: $CHECKSUM"
  mh_log "DEK URL: $DEK_URL"
  #if [ -n "$BASE_IMAGE" ]; then
  if [ -n "$TARGET" ]; then
    #waitcounter=0
    #while [ ! -f /var/lib/nova/instances/_base/$BASE_IMAGE ] && [ $waitcounter -lt 10 ]; do
    #  mh_log "File not found:  /var/lib/nova/instances/_base/$BASE_IMAGE"
    #  waitcounter=$((waitcounter+1))
    #  mh_log "Waiting to find it again; waitcounter=$waitcounter max 10"
    #  sleep 1
    #done
    #if [ -f /var/lib/nova/instances/_base/$BASE_IMAGE ]; then
    if [ -f $TARGET ]; then
      mh_log "Found base image: $TARGET"
      #md5sum /var/lib/nova/instances/_base/$BASE_IMAGE >> $logfile
      # We rely on mh_decrypt to detect if the file is encrypted or not
      # (it could already be decrypted if this isn't the first launch)
      #mh_decrypt /var/lib/nova/instances/_base/$BASE_IMAGE >> $logfile
      mh_decrypt $TARGET >> $logfile
      # Either way we check that now the image checksum should match
      # what was passed in via --checksum
      #local current_md5=$(md5 /var/lib/nova/instances/_base/$BASE_IMAGE)
      local current_md5=$(md5 $TARGET)
      mh_log "Checksum after decryption: $current_md5"
      if [ "$current_md5" != "$CHECKSUM" ]; then
        mh_log "Error: checksum is $current_md5 but expected $CHECKSUM"
      fi
    else
      #mh_log "File not found:  /var/lib/nova/instances/_base/$BASE_IMAGE"
      mh_log "File not found: $TARGET"
    fi
  else
    mh_log "Missing parameter --target"
  fi
  #if [ -d /var/lib/nova/instances/$INSTANCE_NAME ]; then
  #  INSTANCE_DIR=/var/lib/nova/instances/$INSTANCE_NAME 
  #  mh_log "Instance Path: $INSTANCE_DIR"
  #fi
  #if [ -f /var/lib/nova/instances/_base/$PROJECT_ID ]; then
  #  PROJECT_FILE=/var/lib/nova/instances/_base/$PROJECT_ID
  #  mh_log "Base Image:  $PROJECT_FILE"
  #fi
  #if [ -n "$PROJECT_FILE" ]; then
  #  if [ -f "$PROJECT_FILE" ]; then
  #    mh_log "mh_launch: Decrypting $PROJECT_FILE"
  #    mh_decrypt $PROJECT_FILE >> $logfile
  #  else
  #    mh_log "mh_launch: Cannot decrypt file: file not found"
  #  fi
  #else
  #  mh_log "mh_launch: Cannot decrypt file: no base image"
  #fi
}

mh_terminate() {
  mh_log "mh_terminate: $@"
}

mh_suspend() {
  mh_log "mh_suspend: $@"
}

mh_suspend_resume() {
  mh_log "mh_suspend_resume: $@"
}

mh_pause() {
  mh_log "mh_pause: $@"
}

mh_pause_resume() {
  mh_log "mh_pause_resume: $@"
}

mh_fix_aik() {
  local aikdir=/etc/intel/cloudsecurity/cert

  # first prepare the aik for posting. trust agent keeps the aik at /etc/intel/cloudsecurity/cert/aikcert.cer in PEM format.
  if [ ! -f $aikdir/aikcert.crt ]; then
    if [ ! -f $aikdir/aikcert.pem ]; then
      # trust agent aikcert.cer is in broken PEM format... it needs newlines every 76 characters to be correct
      cat $aikdir/aikcert.cer | sed 's/.\{76\}/&\n/g' > $aikdir/aikcert.pem
    fi
    if [ -f $aikdir/aikcert.pem ]; then
      openssl x509 -in $aikdir/aikcert.pem -inform pem -out $aikdir/aikcert.crt -outform der
    fi
  fi

  if [ ! -f $aikdir/aikpubkey.pem ]; then
    if [ -f $aikdir/aikcert.crt ]; then
      openssl x509 -in $aikdir/aikcert.crt -inform der -pubkey -noout > $aikdir/aikpubkey.pem
      openssl rsa -in $aikdir/aikpubkey.pem -inform pem -pubin -out $aikdir/aikpubkey -outform der -pubout
    fi
  fi
}

# example:
# mh_request_dek https://10.254.57.240:8443/v1/data-encryption-key/request/testkey2
mh_request_dek() {
  local url="$1"
  local aikdir
  local dekdir
  if [ -x /opt/xensource/tpm/xentpm ]; then
    local aikblobfile=/opt/xensource/tpm/aiktpmblob
    if [ -f $aikblobfile ]; then
      /opt/xensource/tpm/xentpm --get_aik_pem $aikblobfile > /tmp/aikpubkey.pem
    else
      /opt/xensource/tpm/xentpm --get_aik_pem > /tmp/aikpubkey.pem
    fi
    aikdir=/tmp
    dekdir=/tmp
  else
    mh_fix_aik
    aikdir=/opt/trustagent/configuration/
    dekdir=/var/lib/nova
  fi
  if [ ! -f $aikdir/aik.pem ]; then
    mh_log "Error: Missing AIK Public Key";
    echo "Missing AIK Public Key";
    exit 1
  fi

  #wget --no-check-certificate --header "Content-Type: application/octet-stream" --post-file=$aikdir/aikcert.crt "$url"
  #curl --verbose --insecure -X POST -H "Content-Type: application/octet-stream" --data-binary @$aikdir/aikcert.crt "$url"

  mh_log "Requesting DEK from: $url"

  curl --insecure --silent -X POST -H "Content-Type: text/plain" --data-binary @$aikdir/aik.pem "$url" > $dekdir/mh.dek.base64

  #export MH_DEK_RAW=`cat $dekdir/mh.dek`
  export MH_DEK_BASE64=`cat $dekdir/mh.dek.base64`

  # if client uses the raw key as input to openssl:
  #base64 -d < $dekdir/mh.dek.base64 > $dekdir/mh.dek
  #export MH_DEK=`cat $dekdir/mh.dek`
  
  # if client uses the base64 encoded key as input to openssl:
  export MH_DEK="$MH_DEK_BASE64"

  mh_log "Received DEK from: $url"
  #mh_log "Received DEK: $MH_DEK"
  # XXX TODO need to have an output file option where caller can specify to save the DEK, and an environment option to place it in an env var and then we would also delete these temp files
  #rm $dekdir/mh.dek
  #rm $dekdir/mh.dek.base64

  # XXX DEBUG INSECURE for debugging only:  remove this to protect the key
  mh_log "MH_DEK_BASE64: $MH_DEK_BASE64"
}

mh_log "$@"
parse_args $@

case "$1" in
  version)
    echo "mhagent-0.1"
    ;;
  log)
    shift
    mh_log "LOG" $@
    ;;
  getlog)
    shift
    mh_getlog $@
    ;;
  launch)
    shift
    mh_launch $@
    ;;
  launch-check)
    shift
    PROJECT_FILE=/var/lib/nova/instances/_base/$PROJECT_ID
    mh_log "launch-check $PROJECT_FILE"
    if [ -f $PROJECT_FILE ]; then
      md5sum $PROJECT_FILE >> $logfile
    else
      echo "cannot find $PROJECT_FILE" >> $logfile
    fi
    ;;
  terminate)
    shift
    mh_terminate $@
    ;;
  pause)
    shift
    mh_pause $@
    ;;
  pause-resume)
    shift
    mh_pause_resume $@
    ;;
  suspend)
    shift
    mh_suspend $@
    ;;
  suspend-resume)
    shift
    mh_suspend_resume $@
    ;;
  encrypt)
    shift
    mh_encrypt $@
    ;;
  decrypt)
    shift
    mh_decrypt $@
    ;;
  request-dek)
    shift
    mh_request_dek $@
    ;;
  fix-aik)
    shift
    mh_fix_aik $@
    # since this command is probably being run as root, we should ensure the aik is readable to the nova user:
    # chmod +rx /etc/intel/cloudsecurity
    ;;
  *)
    echo "usage: mhagent version|launch|terminate|pause|pause-resume|suspend|suspend-resume|encrypt|decrypt"
    exit 1
esac

exit $?


