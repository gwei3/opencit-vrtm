Sure, you just need to do a bit of hacking to move the external module into the kernel source tree, tweak the 
Makefiles/Kconfig a bit so that the code is built-in, and then build your kernel image. For example, 
let's say you move the module source into drivers/blah. Then you should add a line to then end 
of drivers/Makefile like

obj-y += blah/
and you should make sure that drivers/blah/Makefile is set up to build your module in, with something like

obj-y += mymodule.o
mymodule-objs := src.c other.c
and so on, where your Makefile is set up however it needs to be to build the particular module you're working on.

No, there isn't code like that. You have an module_init function, but you need initialization code even if 
the code is linked directly into the kernel. There is unload handling code, but if the module is written 
correctly, those functions will be annotated __exit and therefore won't be linked into the kernel image. 

Thus a module has the lifecycle handlers defined via module_init(..) and module_exit(...) macros, while the same 
code statically linked relies on the __init annotation, right? 

For your first question, I assume that you want to build your driver statically into the kernel image(not as a module). First, you select a directory in drivers directory where you want to put your driver files. Assume you want to put your files in drivers/char/. Copy your files into this directory. There will be a Kconfig file in the drivers/char/ directory, open it and add an entry like this in the before the endmenu.

config MYDRIVER
    bool "This is a driver for something"
    default n
    help
      This is a test driver.
Save the file and open Makefile in the same directory. Goto end of the file and add the following entry.

     obj-$(CONFIG_MYDRIVER)            += mydriver.o
That's it you have added the file to the kernel tree. Now, as usual, do make menuconfig and select MYDRIVER.


