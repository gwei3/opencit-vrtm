Instructions for preparing initramfs for FileClient and FileServer
==================================================================

Decompress and unpack the existing initramfs
    cd /tmp
    mkdir init
    cd init
    cp /boot/initramfs.img-`uname -r` initrd.gz
    gunzip -c -9 initrd.gz | cpio -i -d -H newc --no-absolute-filenames

Copy the dynamic link libraries for the executables into the filesystem
for i in `ldd /home/jlm/jlmcrypt/fileServer.exe | cut -d' ' -f3 | sed 's/^\s*//g' | egrep -v '^\s*$'`; do
    source=$i
    dir=`dirname $i`
    mkdir -p $dir
    dest=`echo $i | sed 's?^/??g'`
    echo "Copying $source to $dest"
    cp $source $dest
done

Copy the runtime directory into the filesystem, and get ifconfig, too
    mkdir -p home/jlm/jlmcrypt
    cp -r /home/jlm/jlmcrypt/* home/jlm/jlmcrypt/
    cp /sbin/ifconfig sbin/ifconfig

You might want to clean out some of the unnecessary files here.

Change the initscript (init) to run dmcrypt and change the way the 
system disk is mounted.
  vim init

Here is a simple script that works:

-- start simple script

#!/bin/sh

[ -d /dev ] || mkdir -m 0755 /dev
[ -d /root ] || mkdir -m 0700 /root
[ -d /sys ] || mkdir /sys
[ -d /proc ] || mkdir /proc
[ -d /tmp ] || mkdir /tmp
mkdir -p /var/lock
mount -t sysfs -o nodev,noexec,nosuid sysfs /sys
mount -t proc -o nodev,noexec,nosuid proc /proc
# Some things don't work properly without /etc/mtab.
ln -sf /proc/mounts /etc/mtab

grep -q '\<quiet\>' /proc/cmdline || echo "Loading, please wait..."

# Note that this only becomes /dev on the real filesystem if udev's scripts
# are used; which they will be, but it's worth pointing out
if ! mount -t devtmpfs -o mode=0755 udev /dev; then
	echo "W: devtmpfs not available, falling back to tmpfs for /dev"
	mount -t tmpfs -o mode=0755 udev /dev
	[ -e /dev/console ] || mknod -m 0600 /dev/console c 5 1
	[ -e /dev/null ] || mknod /dev/null c 1 3
fi
mkdir /dev/pts
mount -t devpts -o noexec,nosuid,gid=5,mode=0620 devpts /dev/pts || true
mount -t tmpfs -o "nosuid,size=20%,mode=0755" tmpfs /run
mkdir /run/initramfs
# compatibility symlink for the pre-oneiric locations
ln -s /run/initramfs /dev/.initramfs

/sbin/ifconfig lo 127.0.0.1
# can set up other networks here as needed, e.g., on eth0

# mount /boot as a place to put keys between reboots (e.g., for tcService.exe)
mkdir /boot
mount /dev/sda1 /boot

/bin/busybox sh

-- end simple script

  - untested:
      swapoff -a
      cryptsetup [-c aes -h sha256] -s 128 -d /dev/urandom create swap /dev/sda1
      mkswap /dev/mapper/swap
      swapon /dev/mapper/swap

Put initramfs back together
        find . | cpio -H newc -o|gzip -9 > ../initrd.img-new

Copy it to the boot directory
  sudo cp initrd.gz /boot/initrd.img-staticLinux

Change /etc/grub.d to use this new initramfs.

Consult: http://manpages.ubuntu.com/manpages/karmic/man8/initramfs-tools.8.html

mkdir initramfs{,-old}
 cd initramfs
 gunzip -c -9 /boot/initrd.img-2.6.32-5-686 \
  | cpio -i -d -H newc --no-absolute-filenames
 find > ../initramfs.content
 cd ../initramfs-old
 gunzip -c -9 /boot/initrd.img-2.6.32-5-686.bak \
  | cpio -i -d -H newc --no-absolute-filenames
 find > ../initramfs-old.content
 cd ..
 diff -u initramfs-old.content initramfs.content

A sample init that dynamically loads the driver (don't do this) is:
 1 Decompress initrd into localdirectory
 2 Copy needed drivers in /drvs directory
 3 Copy fileProxy/fileClient/tcService binaries in /bin directory and required libraries in 
     lib and lib64 directories
 4 Copied keys to /bin/HWRoot directory
 5 Replaced init with my custom init
 6 Loaded tcioDD
 7 Configured Ethernet
 8 Script does not boot all services
 9 Package initramfs.igz
10 Copy to /boot
11 Modify entry for OS Tboot section in grub.cfg. replaced initrd by initramfs.igz
12 Reboot machine
13 From cmd line type : /bin/tcService.exe â€“directory /bin/ &
14 tcService connected to keynegoServer on different machine. 

 
Vinay's handcrafted initramfs script
 
#---start
#!/bin/sh
echo "Test CloudProxy minimal boot environment!"
 
[ -d /dev ] || mkdir -m 0755 /dev
[ -d /root ] || mkdir -m 0700 /root
[ -d /sys ] || mkdir /sys
[ -d /proc ] || mkdir /proc
[ -d /tmp ] || mkdir /tmp
 
mkdir -p /proc/net/dev
mkdir -p /var/lock
 
mount -t sysfs -o nodev,noexec,nosuid sysfs /sys
 
# Function for dropping to a shell
shell () {
 
        /bin/busybox sh
}
 
# Basic /dev content, we need it as fast as possible.
mount -t tmpfs dev /dev
mount -t proc proc /proc
 
test -c /dev/null || mknod /dev/null c 1 3
test -c /dev//tty || mknod /dev/tty c 5 0
test -c /dev/urandom || mknod /dev/urandom c 1 9
test -c /dev/random || mknod /dev/random c 1 8
test -c /dev/zero || mknod /dev/zero c 1 5
test -c /dev/tpm0 || mknod /dev/tpm0 c 10 224
test -c /dev/tcioDD0 || mknod /dev/tcioDD0 c 100 0
 
#insmod /drvs/tpm_tis.ko
insmod /drvs/tcioDD.ko
 
echo "loaded tcioDD drivers..."
 
insmod /drvs/e1000e.ko
 
/sbin/ifconfig eth0 192.168.241.11
/sbin/route add default gw 192.168.241.10
 
/bin/busybox sh
 
# Clean up.
umount /proc
umount /sys
 
# Not booting to the real thing at this time.
 
#---end


Standard initramfs init file:

#!/bin/sh

[ -d /dev ] || mkdir -m 0755 /dev
[ -d /root ] || mkdir -m 0700 /root
[ -d /sys ] || mkdir /sys
[ -d /proc ] || mkdir /proc
[ -d /tmp ] || mkdir /tmp
mkdir -p /var/lock
mount -t sysfs -o nodev,noexec,nosuid sysfs /sys
mount -t proc -o nodev,noexec,nosuid proc /proc
# Some things don't work properly without /etc/mtab.
ln -sf /proc/mounts /etc/mtab

grep -q '\<quiet\>' /proc/cmdline || echo "Loading, please wait..."

# Note that this only becomes /dev on the real filesystem if udev's scripts
# are used; which they will be, but it's worth pointing out
if ! mount -t devtmpfs -o mode=0755 udev /dev; then
	echo "W: devtmpfs not available, falling back to tmpfs for /dev"
	mount -t tmpfs -o mode=0755 udev /dev
	[ -e /dev/console ] || mknod -m 0600 /dev/console c 5 1
	[ -e /dev/null ] || mknod /dev/null c 1 3
fi
mkdir /dev/pts
mount -t devpts -o noexec,nosuid,gid=5,mode=0620 devpts /dev/pts || true
mount -t tmpfs -o "nosuid,size=20%,mode=0755" tmpfs /run
mkdir /run/initramfs
# compatibility symlink for the pre-oneiric locations
ln -s /run/initramfs /dev/.initramfs

# Export the dpkg architecture
export DPKG_ARCH=
. /conf/arch.conf

# Set modprobe env
export MODPROBE_OPTIONS="-qb"

# Export relevant variables
export ROOT=
export ROOTDELAY=
export ROOTFLAGS=
export ROOTFSTYPE=
export IP=
export BOOT=
export BOOTIF=
export UBIMTD=
export break=
export init=/sbin/init
export quiet=n
export readonly=y
export rootmnt=/root
export debug=
export panic=
export blacklist=
export resume=
export resume_offset=
export recovery=

# mdadm needs hostname to be set. This has to be done before the udev rules are called!
if [ -f "/etc/hostname" ]; then
        /bin/hostname -b -F /etc/hostname 2>&1 1>/dev/null
fi

# Bring in the main config
. /conf/initramfs.conf
for conf in conf/conf.d/*; do
	[ -f ${conf} ] && . ${conf}
done
. /scripts/functions

# Parse command line options
for x in $(cat /proc/cmdline); do
	case $x in
	init=*)
		init=${x#init=}
		;;
	root=*)
		ROOT=${x#root=}
		case $ROOT in
		LABEL=*)
			ROOT="${ROOT#LABEL=}"

			# support any / in LABEL= path (escape to \x2f)
			case "${ROOT}" in
			*/*)
			if command -v sed >/dev/null 2>&1; then
				ROOT="$(echo ${ROOT} | sed 's,/,\\x2f,g')"
			else
				if [ "${ROOT}" != "${ROOT#/}" ]; then
					ROOT="\x2f${ROOT#/}"
				fi
				if [ "${ROOT}" != "${ROOT%/}" ]; then
					ROOT="${ROOT%/}\x2f"
				fi
				IFS='/'
				newroot=
				for s in $ROOT; do
					newroot="${newroot:+${newroot}\\x2f}${s}"
				done
				unset IFS
				ROOT="${newroot}"
			fi
			esac
			ROOT="/dev/disk/by-label/${ROOT}"
			;;
		UUID=*)
			ROOT="/dev/disk/by-uuid/${ROOT#UUID=}"
			;;
		/dev/nfs)
			[ -z "${BOOT}" ] && BOOT=nfs
			;;
		esac
		;;
	rootflags=*)
		ROOTFLAGS="-o ${x#rootflags=}"
		;;
	rootfstype=*)
		ROOTFSTYPE="${x#rootfstype=}"
		;;
	rootdelay=*)
		ROOTDELAY="${x#rootdelay=}"
		case ${ROOTDELAY} in
		*[![:digit:].]*)
			ROOTDELAY=
			;;
		esac
		;;
	resumedelay=*)
		RESUMEDELAY="${x#resumedelay=}"
		;;
	loop=*)
		LOOP="${x#loop=}"
		;;
	loopflags=*)
		LOOPFLAGS="-o ${x#loopflags=}"
		;;
	loopfstype=*)
		LOOPFSTYPE="${x#loopfstype=}"
		;;
	cryptopts=*)
		cryptopts="${x#cryptopts=}"
		;;
	nfsroot=*)
		NFSROOT="${x#nfsroot=}"
		;;
	netboot=*)
		NETBOOT="${x#netboot=}"
		;;
	ip=*)
		IP="${x#ip=}"
		;;
	boot=*)
		BOOT=${x#boot=}
		;;
	ubi.mtd=*)
		UBIMTD=${x#ubi.mtd=}
		;;
	resume=*)
		RESUME="${x#resume=}"
		;;
	resume_offset=*)
		resume_offset="${x#resume_offset=}"
		;;
	noresume)
		noresume=y
		;;
	panic=*)
		panic="${x#panic=}"
		case ${panic} in
		*[![:digit:].]*)
			panic=
			;;
		esac
		;;
	quiet)
		quiet=y
		;;
	ro)
		readonly=y
		;;
	rw)
		readonly=n
		;;
	debug)
		debug=y
		quiet=n
		exec >/run/initramfs/initramfs.debug 2>&1
		set -x
		;;
	debug=*)
		debug=y
		quiet=n
		set -x
		;;
	break=*)
		break=${x#break=}
		;;
	break)
		break=premount
		;;
	blacklist=*)
		blacklist=${x#blacklist=}
		;;
	netconsole=*)
		netconsole=${x#netconsole=}
		;;
	BOOTIF=*)
		BOOTIF=${x#BOOTIF=}
		;;
	hwaddr=*)
		BOOTIF=${x#BOOTIF=}
		;;
	recovery)
		recovery=y
		;;
	esac
done

if [ -n "${noresume}" ]; then
	export noresume
	unset resume
else
	resume=${RESUME:-}
fi

maybe_break top

# export BOOT variable value for compcache,
# so we know if we run from casper
export BOOT

# Don't do log messages here to avoid confusing graphical boots
run_scripts /scripts/init-top

maybe_break modules
[ "$quiet" != "y" ] && log_begin_msg "Loading essential drivers"
load_modules
[ "$quiet" != "y" ] && log_end_msg

[ -n "${netconsole}" ] && modprobe netconsole netconsole="${netconsole}"

maybe_break premount
[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/init-premount"
run_scripts /scripts/init-premount
[ "$quiet" != "y" ] && log_end_msg

maybe_break mount
log_begin_msg "Mounting root file system"
. /scripts/${BOOT}
parse_numeric ${ROOT}
maybe_break mountroot
mountroot
log_end_msg

maybe_break bottom
[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/init-bottom"
run_scripts /scripts/init-bottom
[ "$quiet" != "y" ] && log_end_msg

# Preserve information on old systems without /run on the rootfs
if [ -d ${rootmnt}/run ]; then
	mount -n -o move /run ${rootmnt}/run
else
	# The initramfs udev database must be migrated:
	if [ -d /run/udev ] && [ ! -d /dev/.udev ]; then
		mv /run/udev /dev/.udev
	fi
	# The initramfs debug info must be migrated:
	if [ -d /run/initramfs ] && [ ! -d /dev/.initramfs ]; then
		mv /run/initramfs /dev/.initramfs
	fi
	umount /run
fi

# Move virtual filesystems over to the real filesystem
mount -n -o move /sys ${rootmnt}/sys
mount -n -o move /proc ${rootmnt}/proc

validate_init() {
	checktarget="${1}"

	# Work around absolute symlinks
	if [ -d "${rootmnt}" ] && [ -h "${rootmnt}${checktarget}" ]; then
		case $(readlink "${rootmnt}${checktarget}") in /*)
			checktarget="$(chroot ${rootmnt} readlink ${checktarget})"
			;;
		esac
	fi

	# Make sure the specified init can be executed
	if [ ! -x "${rootmnt}${checktarget}" ]; then
		return 1
	fi

	# Upstart uses /etc/init as configuration directory :-/
	if [ -d "${rootmnt}${checktarget}" ]; then
		return 1
	fi
}

# Check init bootarg
if [ -n "${init}" ]; then
	if ! validate_init "$init"; then
		echo "Target filesystem doesn't have requested ${init}."
		init=
	fi
fi

# Common case: /sbin/init is present
if [ ! -x "${rootmnt}/sbin/init" ]; then
	# ... if it's not available search for valid init
	if [ -z "${init}" ] ; then
		for inittest in /sbin/init /etc/init /bin/init /bin/sh; do
			if validate_init "${inittest}"; then
				init="$inittest"
				break
			fi
		done
	fi

	# No init on rootmount
	if ! validate_init "${init}" ; then
		panic "No init found. Try passing init= bootarg."
	fi
fi

maybe_break init

# don't leak too much of env - some init(8) don't clear it
# (keep init, rootmnt)
unset debug
unset MODPROBE_OPTIONS
unset DPKG_ARCH
unset ROOTFLAGS
unset ROOTFSTYPE
unset ROOTDELAY
unset ROOT
unset IP
unset BOOT
unset BOOTIF
unset UBIMTD
unset blacklist
unset break
unset noresume
unset panic
unset quiet
unset readonly
unset resume
unset resume_offset

# Chain to real filesystem
exec run-init ${rootmnt} ${init} "$@" ${recovery:+--startup-event=recovery} <${rootmnt}/dev/console >${rootmnt}/dev/console 2>&1
panic "Could not execute run-init."


Wrong:
    gunzip initrd.gz
    cpio -iv < initrd


From http://reboot.pro/topic/14547-linux-load-your-root-partition-to-ram-and-boot-it/

his tutorial will guide you through the steps to modify your initramfs to load all files from / to a tmpfs. This will only work with Debian 5 or newer and Ubuntu 9 ? or any unix thats supports booting from a initramfs. Since this is a virtual filesystem in RAM, not a virtual harddisk, this has many advantages.

What you need:
* lots of RAM
* Debian based distribution or any that supports booting from initramfs
* mkinitramfs or a tool to build a new initramfs
* some linux knowledge
* no need to create an image
* no need for Grub4Dos
* no need for a "special driver"

Step 1:
Choose a distribution thats supports booting from initramfs. (like ubuntu)

Step 2:
Install to harddisk. Make sure you split it into multiple partitions (/, /boot, /home, swap, ...).

Step 3:
Boot your new system, install updates, drivers if neccessary (this will improve performance), strip it down to the minimum. Every file will be loaded to RAM ! A fresh install uses about 2 GB auf harddisk-space.

Step 4:
modify /etc/fstab :
* make a backup
cp /etc/fstab /etc/fstab.bak* find the line specifing the root partition and change it in:
none / tmpfs defaults 0 0* save

Step 5:
edit the local script in your initramfs:
cd /usr/share/initramfs-tools/scripts/* make a backup of /usr/share/initramfs-tools/scripts/local
cp local local.bak* modify local, find this line:
# FIXME This has no error checking

# Mount root

mount ${roflag} -t ${FSTYPE} ${ROOTFLAGS} ${ROOT} ${rootmnt}* change it to:
# FIXME This has no error checking

# Mount root

#mount ${roflag} -t ${FSTYPE} ${ROOTFLAGS} ${ROOT} ${rootmnt}

mkdir /ramboottmp

mount ${roflag} -t ${FSTYPE} ${ROOTFLAGS} ${ROOT} /ramboottmp

mount -t tmpfs -o size=100% none ${rootmnt}

cd ${rootmnt}

cp -rfa /ramboottmp/* ${rootmnt}

umount /ramboottmp
* save
* execute, or rebuild initramfs
mkinitramfs -o /boot/initrd.img-ramboot* replace modified local with original file
cp -f local.bak localStep 6:
* modify this file (needs a better solution)
/boot/grub/grub.cfg* copy the first boot entry and replace the /initrd line with this:
/initrd /initrd.img-ramdisk* label the new entrie as RAMBOOT
This will boot our generated initramfs instead the original one.
Step 7:
* reboot
* choose standart boot (no ramdisk)
* choose RAMBOOT and all your files on the root partition will be loaded to a tmpfs

Results:
Test setup:
*Kernel : Linux 2.6.38-8-generic (i686)
*Compiled : #42-Ubuntu SMP Mon Apr 11 03:31:50 UTC 2011
*Distribution : Ubuntu 11.04
*no graphics driver
*Desktop HP 8100E
*Core i7 860
*4GB Memory 2 Modules (DDR3)
*WDVeliciraptor 10k rpm 160GB 

Tiotest results for 4 concurrent io threads:

,----------------------------------------------------------------------.

| Item                  | Time     | Rate         | Usr CPU  | Sys CPU |

+-----------------------+----------+--------------+----------+---------+

| Write         800 MBs | 0.1489 s | 5372.806 MB/s |  2.80 %  | 32.40 % |

| Random Write   16 MBs | 0.0025 s | 6320.793 MB/s |   0.0 %  |   0.0 % |

| Read          800 MBs | 0.0928 s | 8616.790 MB/s |  11.7 %  |  11.7 % |

| Random Read    16 MBs | 0.0021 s | 7454.676 MB/s |   0.0 %  |   0.0 % |

`----------------------------------------------------------------------&#39;

Tiotest latency results:

,-------------------------------------------------------------------------.

| Item         | Average latency | Maximum latency | % >2 sec | % >10 sec |

+--------------+-----------------+-----------------+----------+-----------+

| Write        |        0.003 ms |        0.048 ms |  0.00000 |   0.00000 |

| Random Write |        0.002 ms |        0.011 ms |  0.00000 |   0.00000 |

| Read         |        0.002 ms |        0.025 ms |  0.00000 |   0.00000 |

| Random Read  |        0.002 ms |        0.023 ms |  0.00000 |   0.00000 |

|--------------+-----------------+-----------------+----------+-----------|

| Total        |        0.002 ms |        0.048 ms |  0.00000 |   0.00000 |

`--------------+-----------------+-----------------+----------+-----------&#39

From http://www.stlinux.com/howto/initramfs

initramfs: an overview

The initial ramdisk, or initrd, is a temporary file system commonly used in the boot process 
of the Linux kernel. The kernel typically uses the ramdisk for making preparations before 
the real root file system can be mounted. For 2.4 and earlier kernels, initrd is still the 
only way to perform these tasks. However, the kernel developers chose to implement a new 
mechanism in 2.6 for several reasons.

A ramdisk (such as initrd) is a ram-based block device, which means that it is a fixed size 
piece of memory that can be formatted and mounted like a disk. This means the contents of 
the ramdisk must be formatted and prepared with special tools (such as mke2fs and losetup), 
and like all block devices it requires a filesystem driver to interpret the data at runtime. 
This also imposes an artificial size limit that either wastes space (if the ramdisk is not 
full, the extra memory it takes up cannot be used for anything else) or limits capacity 
(if the ramdisk fills up but other memory is still free, you cannot expand it without 
reformatting it).

Ramdisks actually waste even more memory due to caching. Linux is designed to cache all 
files and directory entries read from or written to block devices, so Linux copies data 
to and from the ramdisk into the "page cache" (for file data), and the "dentry cache" 
(for directory entries). The disadvantage of the ramdisk pretending to be a block device 
is that Linux must treat it like a block device.

initramfs: a brief history

A few years ago, Linus Torvalds asked: what if Linux's cache could be mounted like a 
filesystem? Just keep the files in cache and never get rid of them until they are deleted 
or the system reboots? Linus wrote a tiny wrapper around the cache called ramfs, and 
other kernel developers created an improved version called tmpfs, which can write the 
data to swap space, and limit the size of a given mount point so it fills up before 
consuming all available memory. initramfs is an instance of tmpfs.

Unlike block device ramdisks, ram-based filesystems can automatically grow or shrink 
to fit the size of the data they contain. Adding files to a ramfs (or extending existing 
files) automatically allocates more memory; deleting or truncating files frees that 
memory. There is no longer any duplication between the block device and cache, because 
there is no block device: the copy in the cache is the only copy of the data. Another 
advantage is that this is not new code, but a new application for the existing Linux 
caching code, which means it adds almost no size, is very simple, and is based on an 
extremely well tested infrastructure.

A system using initramfs as its root filesystem does not even need a single filesystem 
driver built into the kernel, because there are no block devices to interpret as 
filesystems: only files living in memory.

Comparison of initrd and initramfs

The change in the underlying infrastructure was a reason for the kernel developers 
to create a new implementation, but at the same time, they cleaned up a lot of bad 
behavior and assumptions.

initrd was designed as front-end to the old root= root device detection code, not a 
replacement for it. It ran a program called /linuxrc, which was intended to perform setup 
functions (like logging onto the network, determining which of several devices contained 
the root partition, or associating a loopback device with a file), tell the kernel which 
block device contained the real root device (by writing the de_t number to 
/proc/sys/kernel/real-root-dev), and then return to the kernel so that the kernel could 
mount the real root device and execute the real init program.

This assumes that the "real root device" is a block device rather than a network share, 
and also assumes that initrd is not itself going to be the real root filesystem. The 
kernel did not even execute /linuxrc as the special process ID 1, because that process 
ID (and its special properties, such as being the only process that cannot be killed 
with kill -9) was reserved for init, which the kernel was waiting to run only after 
it had mounted the real root filesystem.

With initramfs, the kernel developers removed all these assumptions. When the kernel 
launches /init out of initramfs, the kernel does not need to make its own decisions and 
can go back to following orders. With initramfs, the kernel does not care where the real 
root filesystem is (it remains initramfs until further notice), and the /init program 
from initramfs is run as a real init, with process ID of 1. (If initramfs init needs 
to hand that special process ID off to another program, it can use the exec() 
syscall like everybody else.)

Booting with initramfs: how to configure the kernel

To configure Linux to boot by mounting an initramfs image internally, set the 
following items on the kernel config:


 CONFIG_BLK_DEV_INITRD=y
 CONFIG_INITRAMFS_SOURCE=<Initramfs cpio image path>

After making these changes to the settings, re-compile the kernel. Finally, the kernel 
can be booted as follows (for instance, we report a boot on a mb442 by using a "vmlinux" 
with the above settings enabled):

host% st40load_gdb -t stmc:mb442:st40 -c sh4tp -b vmlinux mem=64m

No other parameters have to be passed to st40load_gdb to boot with initramfs, as the 
kernel mounts that image automatically.

initramfs: how to create a rootfs image

To boot Linux by using the initramfs image, create a typical ext2 (or ext3) filesystem 
structure in which the only difference with respect to the standard ext2/3 root filesystem 
used in SysV, or busybox, is related to the init file. 

Usually, the init file is placed under /sbin (for both SysV and Busybox). In the initramfs 
rootfs image, the init file has to be placed under the root, /, as the kernel tries to 
execute /init instead of /sbin/init in case the initramfs image was mounted after boot. 
A typical initramfs filesystem structure is as follows:

target% ls 
bin  dev  etc  home  include  init  lib mnt  proc  sys  sbin  tmp  usr  var

A guide to the mkshinitramfs tool

The tool mkshinitramfs has been created to improve the process of initramfs rootfs 
image creation. The current version of the tool is 1.0. To get information about the 
tool's parameters, type the following command line:


host# ./mkshinitramfs -h
mkshinitramfs-1.0, 
usage: mkshinitramfs [-h|-H   Help]
       mkshinitramfs [-o|O:  <Initramfs CPIO image with switch option to HDD(/dev/sda1)>]
       mkshinitramfs [-s|S:  <Initramfs CPIO image with shell on Initramfs>]
       mkshinitramfs [-p|P:  <target rootfs path> | default: /opt/STM/STLinux-2.3/devkit/sh4/target/]
       mkshinitramfs [-k|K:  <SH kernel version>  | default: 2.6.23_stm23_0121]
       mkshinitramfs [-b|B:  <used board> | default: mb442 (STi710x based board)]

mkshinitramfs must be executed as "root" on the host machine in which a full target root 
filesystem has previously been installed. It is configured to use default parameters, 
as listed in the output from the -h option. To change any of the parameters, apply the 
command line options listed in the help.

The tool mkshinitramfs creates a short initramfs. If invoked with the -s option, the 
generated initramfs is the final rootfs. If invoked with the -o option, the generated 
initramfs is a temporary rootfs to be switched to the real one on the HDD.

The script mkshinitramfs internally defines some variables that are useful when defining 
which files, libraries, scripts and tools are to be placed on the initramfs image. 
The variables are:

$DIRS
$BINFILES
$SBINFILES
$ETCFILES1
$USRBINFILES

Version 1.0 of the mkshinitramfs tool can be downloaded from mkshinitramfs tool as a 
compressed tar.gz file.

If the initramfs rootfs is created to be used temporarily before switching to the real 
target rootfs on a hard disk drive, a setup script is needed, which is then passed to 
the chroot in order to setup the final real rootfs properly. This script loads the user 
space services needed at runtime, such as klogd, udev, D-Bus, and so forth.

If the -o option is used, mkshinitramfs generates a CPIO image in which the following 
command line is inserted after the kernel mounts the initramfs:

mount /dev/sda1 /mnt
chroot /mnt /etc/init.d/rcS-initramfs

The script rcS-initramfs performs the same operations performed at rcS level and runlevel3 
by a classical SysV init system. A typical rcS-initramfs user space start-up script can 
be downloaded from rcS-initramfs start-up script as a compressed tar.gz file.

