				RP Crypto APIs 

1.0 Introduction:
The RP crypto APIs provide a C/C++ level interface to cryptographic primitives to be used by RP projects. The functionalities are broadly categorized into the following subfunctionalities:

1) Crypto API
	- Key generation
	- Digest
        - HMAC
        - Key Derivation Functions
	- Signature
	- Encryption/Decryption
2) Attestation and verification
3) Trust Establishment
4) Secure storage
5) Utility functions


The first release 1.0 contains only the Crypto APIs and Utility APIs implemented. The others will be implemented in future and currently returns -99 to indicate that these are not implemented.

2.0 API data types:
The following lists some of the data types that is relevant for discussions in this document. These have been taken from rpapi.h which contan the API function prototypes.

typedef unsigned char       byte;
typedef unsigned int        uint;
typedef unsigned char       u8;
typedef unsigned            u32;
typedef long long unsigned  u64;


typedef struct _data_buf {		
	unsigned int	len;
	byte		*data;
} Data_buffer;

typedef struct _data_buf SymKey;

typedef struct _rsa_key_pair {
	Data_buffer	n;	//modulus
	Data_buffer	e;	//public exponent
	Data_buffer	d;  	//private exponent 
	Data_buffer	p;	//prime 1
	Data_buffer	q;	//prime 2
} RSAKeyPair;

typedef struct _rsa_public_key {
	Data_buffer	n;	//modulus
	Data_buffer	e;	//public exponent
} RSAPublicKey;

typedef struct _rsa_private_key{
	Data_buffer	n;  //modulus
	Data_buffer	d;  //private exponent 
	Data_buffer	p;  //prime 1
	Data_buffer	q;  //prime 2
} RSAPrivateKey;

typedef void* Digest_context;

#define NOPAD        0
#define PKCSPAD      1
#define SYMPAD       2

#define RSANOPADDING         0
#define RSAPKCS1PADDING      1
#define RSAPKCS1OAEPPADDING  2

#define NOHASH       0
#define SHA256HASH   1
#define SHA1HASH     2

#define NOMODE       0
#define CBCMODE      2

#define NOALG        0
#define AES128       1
#define AES256       2
#define RSA1024      6
#define RSA2048      7

#define NOHMAC       0
#define HMACSHA256   1

#define NOKEYTYPE        0
#define AESKEYTYPE       1
#define RSAKEYTYPE       2


#define AES128BYTEBLOCKSIZE        16
#define AES128BYTEKEYSIZE          16
#define AES256BYTEBLOCKSIZE        16
#define AES256BYTEKEYSIZE          32

#define RSA1024BYTEKEYSIZE        128
#define RSA2048BYTEKEYSIZE        256
#define RSA1024BYTEBLOCKSIZE      128
#define RSA2048BYTEBLOCKSIZE      256

#define SHA1BLOCKBYTESIZE          64
#define SHA1DIGESTBYTESIZE         20
#define SHA256BLOCKBYTESIZE        64
#define SHA256DIGESTBYTESIZE       32
#define SHA512BLOCKBYTESIZE        64
#define SHA512DIGESTBYTESIZE       64

#define SMALLKEYSIZE            128
#define BIGKEYSIZE              512
#define KEYNAMEBUFSIZE          128
#define KEYTYPEBUFSIZE          128
#define BIGSYMKEYSIZE            64
#define SMALLSYMKEYSIZE          32
#define BIGBLOCKSIZE             32


2.1 API Return values:
All the APIs return a value of 1 to indicate success. 0 or negative values indicate failure. APIs that return -99 are not yet implemented.

2.2 API Prototyes:
The following is the list of the  function prototypes:

2.3 Buffer Allocation/Deallocation Convention:  
It is the user's responsibility to allocate/deallocate any buffers involved. If the size of the buffer allocated is not enough, the APIs will return failure. 


3.0 Crypto API
	
3.1 Key generation APIs:
There are two kinds of APIs provided. One will generate a key in a buffer provided by the user. The other will write the generated key to a file in base64. 

int GenSymKey(const char* szKeyType, const char* szReserved, SymKey *keyOut);
int GenRSAKey(const char* szKeyType,  const char* szReserved, u64 pubExp, RSAKeyPair *keyOut);
int GenKeyFile(const char* szKeyType, const char* szOutFile);

Parameter Descriptions:
szKeyType: ["AES128" | "AES256" | "RSA1024" | "RSA2048"]
szReserved: Currently not used.
keyOut: Must have the data and len fields populated before calling these functions.
pubExp: This is currently not used and default to 65537.
szOutFile: This is when the generated key needs to be output to a file and base64 encoded.



3.2 Key Derivation Functions:
This function is used to derive symmetric key from another key e.g. password. Key derivation functions (KDF) derive key material from another source of entropy while preserving the entropy of the input and being one-way. The RP library currently support PBKDF2 algorithm. RP library uses SHA256 in this function.


int DeriveKey(const char* szKeyType, const char* szMethod, Data_buffer *password, Data_buffer *salt, SymKey *keyOut,u32 iterations);

Parameter Descriptions:
szKeyType: ["AES128" | "AES256"i]
szMethod: PBKDF2
password:  Pointer to Data_buffer structure containg the password and the length.
salt: 
keyOut: The buffer for the derived key
iterations: number of rounds

int GetPublicKeyFromCert(const char* szCertificate, RSAPublicKey* pubKey);
Note: The above(GetPublicKeyFromCert) will be implemented in one of the future releases .

3.3 Message digests/hashes:
The first set provides the capability to compute the digest in chunks of blocks. The second set provides a mechanism to compute  the digest/hash in one shot if there is no need for multiple blocks.
int Sha256InitDigest(char* szDigestType, Digest_context *ctx);
int Sha256UpdateDigest(Digest_context *ctx, Data_buffer *data);
int Sha256GetDigest(Digest_context *ctx,  Data_buffer *digest);
int Sha256CloseDigest(Digest_context *ctx);
int Sha1InitDigest(char* szDigestType, Digest_context *ctx);
int Sha1UpdateDigest(Digest_context *ctx, Data_buffer *data);
int Sha1GetDigest(Digest_context *ctx,  Data_buffer *digest);
int Sha1CloseDigest(Digest_context *ctx);
	
int GetSha256Digest(Data_buffer *In,Data_buffer *Digest);
int GetSha1Digest(Data_buffer *In,Data_buffer *Digest);

Parameter Descriptions:
szDigestType: ["SHA-1" | "SHA-256"]

3.4 MAC - message authentication code:
THis is based on SHA256.

int GetMAC(char* szMACType, SymKey *key, Data_buffer *digest, Data_buffer *mac);

Parameter Descriptions:
szMACType: HMAC

	
3.5 Sign and verification
This subfunctionality also have two sets of APIs. The first one uses in memory buffers. The second set uses files. In both cases, the signature is  in raw form i.e. they are not base64 encoded. Internally, we use PKCS 1.5 for padding.

int Sign(const char* szAlgorithm, Data_buffer *digestIn, Data_buffer *sigOut, RSAPrivateKey* privKey);
int Verify(const char* szAlgorithm, Data_buffer *digestIn, Data_buffer *sigIn, RSAPublicKey* pubKey);
int SignFile(const char* szAlgorithm, const char* szInFileName, Data_buffer *sigOut, RSAPrivateKey* privKey);
int VerifyFile(const char* szAlgorithm, const char* szInFileName, Data_buffer *sigIn, RSAPublicKey* pubKey);

Parameter Descriptions:
szAlgorithm: ["rsa2048-sha256-pkcspad" | "rsa1024-sha256-pkcspad"]

3.6 Encryption/Decryption:
Encryption and decryption using symmetric keys has two sets of APIs - 1) The set using memory buffers 2) The other set using files. RSA encryption/decryption is supported only for in-memory buffers.

int Encrypt(SymKey* key, SymKey* intKey, Data_buffer * dataIn, Data_buffer *dataOut, uint mode, uint alg, uint pad, uint mac);
int Decrypt(SymKey* szKey, SymKey* intKey, Data_buffer * dataIn, Data_buffer *dataOut, uint mode, uint alg, uint pad, uint mac);
int EncryptFile(SymKey* szKey, SymKey* intKey, const char* szInFileName, const char* szOutFileName, uint mode, uint alg, uint pad, uint mac);
int DecryptFile(SymKey* szKey, SymKey* intKey, const char* szInFileName, const char* szOutFileName, uint mode, uint alg,uint pad, uint mac);
int RSAEncrypt(const char* szPKPadding, Data_buffer * dataIn, Data_buffer *dataOut, RSAPublicKey* pubKey);
int RSADecrypt(const char* szPKPadding, Data_buffer * dataIn, Data_buffer *dataOut, RSAPrivateKey* privKey);

Parameter Descriptions:
alg: [AES128 | AES256]
Note: Currently AES128 is supported.
mode:CBCMODE
pad: SYMPAD
mac: HMACSHA256
szPKPadding: "RSA_PKCS1_PADDING"|"RSA_PKCS1_OAEP_PADDING"|"RSA_NO_PADDING"

Note 1: Currently only "RSA_NO_PADDING" is supported.
Note 2: The interfaces( 4 APIs) for Symmetric Encryption/Decryption have been changed in release 1.2. Now the interface has an additional parameter for an integrity key.  

3.7 Random number generator:
The following are used in the generation of cryptographic random number generation
int InitCryptoRand();
int GetCryptoRandom(int iNumBits, byte* buf);
int CloseCryptoRand();

iNumBits: Number of bits. 
buf: buffer for the crypto random number

3.8 Utility functions:
This first two are for base64 encoding and decoding. The last one is for getting the crypto random number base64 encoded.

int ToBase64(int inLen, const byte* pbIn, int* poutLen, char* szOut, int iDirFwd);
int FromBase64(int inLen, const char* szIn, int* poutLen, unsigned char* puOut, int iDirFwd);
int GetBase64Rand(int iBytes, byte* puR, int* pOutSize, char* szOut);

Parameter Descriptions:
poutLen: This shold be set to the size of the buffer. On successful return, it will contain the length of the encoded/decoded data. So save this value if you need the value later, for example, freeing the dynamically allocated buffer.
szOut,puOut: Output buffer for encoding and decoding.
iBytes: number of bytes.
puR: This is the buffer for the unencoded crypto random number generated before base64 encoding.

3.9 Crypto Lib init/exit functions:
RPLibInit() is invoked at the begining of the program using RP crypto library and RPLibExit  is invoked before the program exits.

int RPLibInit();
int RPLibExit();

3.10 Big number initialization
This is used when RSA crypto is involved.
void InitBigNum();


3.11 Identity attestation and verification:
Trusted Execution Environment (TEE) identify is defined as the hash of the code and data measured
by HW at the time TEE instance launch.  Attestation is this identity singed by the private key held in HW root of trust provider.

In the case of Intel TXT, the TPM is updated with a list of all the software measurements committed to the PCRs, and can then sign them with a private key known only to the TPM. Thus, a trusted client can prove to a third party what software was launched in TEE.

int GenerateQuote(Data_buffer *nonce, Data_buffer * challengeIn, Data_buffer *quoteOut);
int VerifyQuote( Data_buffer * quoteIn,  const char* szCertificate, int iCertFlag);

Parameter Descriptions:
nonce: Contains a reshly generated random number.
challengeIn: Contains a public key(XML format).
quoteOut: Buffer where the quote will be stored.
szCertificate: Certificate. Currently this accepts the public keu(XML format).
iCertFlag: Whether a certificate is being passed or a key is being passed.(Both in XML format). Currently this flag must be 0 because only  public keys are accepted.


3.12 Remote trust establishment: 
This will be used to establish shared secret with remote software program, after verifying its identityi.
The following API(EstablishSessionKey) will be implemented in one of the future releases. 

int EstablishSessionKey (const char* szRemoteMachine, const char* method, int* nuKeysOut, Data_buffer **keys);

3.13 Secure data:
During runtime of TEE, data can be protected by keeping it within the boundary (TCB).  To store
the secrets in persistent storage the data is encrypted by TEE in a way that it can be decrypted
by the same TEE identity on that machine.  Sealed data can be stored in the non-secure persistent
storage.

int Seal(Data_buffer * secretIn, Data_buffer *dataOut);
int UnSeal(Data_buffer * dataIn, Data_buffer *secretOut);

<----------------------------------------------------------------------------------------------->
